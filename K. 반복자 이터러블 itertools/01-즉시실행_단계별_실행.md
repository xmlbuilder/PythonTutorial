## 🧠 yield란?
yield는 Python에서 generator를 정의하는 키워드로,
함수의 실행을 **중단(suspend)**하고 값을 반환한 뒤,
다음 next() 호출 시 중단된 지점부터 다시 실행됩니다.

## 🔁 return vs yield
| 항목             | `return`                          | `yield`                                      |
|------------------|------------------------------------|-----------------------------------------------|
| 동작 방식        | 함수 실행 종료 + 값 반환           | 값 반환 + 함수 상태 유지 (중단 후 재개 가능)   |
| 반복 가능 여부   | ❌ 반복 불가                        | ✅ 반복자처럼 사용 가능 (`next()`로 재개)       |
| 메모리 사용      | 즉시 전체 결과 생성 → 메모리 부담  | 지연 실행 → 메모리 효율적                      |
| 사용 목적        | 단일 결과 반환                     | 여러 값 순차 반환 (스트리밍, 반복 처리 등)     |
| 예외 발생 시점   | 반환 후 함수 종료                  | 모든 `yield` 소진 후 `StopIteration` 발생      |


## 🔍 동작 흐름 예제 분석
```python
def generator_ex1():
    print("start")
    yield 'A point'
    print("Continue")
    yield 'B Point'
    print("End")
```

## 실행 흐름
```python
temp = iter(generator_ex1())  # generator 객체 생성
print(next(temp))             # → start → 'A point'
print(next(temp))             # → Continue → 'B Point'
print(next(temp))             # → End → StopIteration
```

→ yield는 값을 반환하면서 함수 실행을 멈추고,
다음 next() 호출 시 그 다음 줄부터 재개됩니다.

## 🧱 내부 구조: 상태 머신처럼 동작
- generator_ex1() 호출 시 → generator 객체 생성
- next() 호출 시 → 코루틴처럼 중단점부터 실행
- StopIteration 발생 시 → 반복 종료

## 🧠 병행성과의 관계
| 개념       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 병행성     | 하나의 thread가 여러 작업을 번갈아 수행 → `yield`로 흐름 제어 가능     |
| 병렬성     | 여러 thread가 동시에 작업 수행 → `yield`는 직접적인 병렬성은 아님       |
| `yield`    | 병행적 흐름 제어에 적합 (예: 비동기 처리, 스트리밍, 반복자 설계 등)     |

→ yield는 병렬 처리용 도구는 아니지만,
병행적 흐름 제어에는 매우 유용합니다.

🧠 리스트 컴프리헨션 vs 제너레이터 표현식
```python
temp2 = [x * 3 for x in generator_ex1()]  # 즉시 실행, 메모리 사용 많음
temp3 = (x * 3 for x in generator_ex1())  # 지연 실행, 메모리 효율적
```
## ✅ 차이 요약
| 표현식 유형           | 실행 시점       | 메모리 사용     | 반복 방식     |
|------------------------|------------------|------------------|----------------|
| 리스트 컴프리헨션     | 즉시 전체 실행   | 높음             | 한 번에 생성   |
| 제너레이터 표현식     | 필요할 때 실행   | 낮음             | 하나씩 생성    |


## ✅ 요약: yield의 핵심 장점
| 장점               | 설명                                      |
|--------------------|-------------------------------------------|
| 지연 실행          | 필요한 순간에만 값 생성 → 메모리 절약       |
| 상태 유지          | 함수 내부 상태를 유지하며 중단/재개 가능     |
| 반복자 구현 용이   | `__iter__()` 없이도 반복자처럼 동작 가능     |
| 병행 흐름 제어     | 여러 작업을 순차적으로 처리할 때 유용        |
| 스트리밍 처리      | 대용량 데이터 처리에 적합 (`for`, `next`)    |

---

## 아래는 temp2와 temp3의 실행 과정을 단계별로 비교한 설명.
두 표현식은 모두 generator_ex1()을 기반으로 하지만, 실행 시점과 흐름이 완전히 다릅니다.

## 🔁 먼저 generator_ex1() 다시 확인
```python
def generator_ex1():
    print("start")
    yield 'A point'
    print("Continue")
    yield 'B Point'
    print("End")
```


## 🧪 1. 리스트 컴프리헨션: temp2 = [x * 3 for x in generator_ex1()]
### 실행 흐름
- generator_ex1() 호출 → generator 객체 생성
- for x in generator_ex1() → 즉시 반복 시작
- 첫 번째 yield → "start" 출력 → 'A point' 반환
- 'A point' * 3 → 'A pointA pointA point' 저장
- 두 번째 yield → "Continue" 출력 → 'B Point' 반환
- 'B Point' * 3 → 'B PointB PointB Point' 저장
- "End" 출력 → StopIteration 발생 → 반복 종료
- 최종 리스트 생성 완료
### 출력 결과
```python
['A pointA pointA point', 'B PointB PointB Point']
```

## 콘솔 출력
```python
start  
Continue  
End
```

→ 모든 print()는 리스트 생성 시점에 즉시 실행됨

## 🧪 2. 제너레이터 표현식: temp3 = (x * 3 for x in generator_ex1())
### 실행 흐름
- generator_ex1() 호출 → generator 객체 생성
- temp3는 아직 아무 것도 실행하지 않음 (지연 실행)
- for x in temp3: 시작 → 첫 번째 next() 호출
- "start" 출력 → 'A point' 반환 → 'A pointA pointA point' 출력
- 두 번째 next() 호출 → "Continue" 출력 → 'B PointB PointB Point' 출력
- 세 번째 next() → "End" 출력 → StopIteration 발생 → 반복 종료
### 출력 결과
```python
A pointA pointA point  
B PointB PointB Point
```

### 콘솔 출력
```
start  
A pointA pointA point  
Continue  
B PointB PointB Point  
End
```

→ print()는 실제로 값을 꺼낼 때마다 실행됨

## ✅ 차이 요약
| 표현식 유형           | 실행 시점       | 메모리 사용     | 콘솔 출력 순서         |
|------------------------|------------------|------------------|--------------------------|
| 리스트 컴프리헨션     | 즉시 전체 실행   | 높음             | start → Continue → End   |
| 제너레이터 표현식     | 필요할 때 실행   | 낮음             | start → A → Continue → B → End |




## 🔍 주요 컬렉션에서의 실행 방식 비교
| 표현식 유형 | 예시                                 | 실행 시점       | 메모리 사용 | 반복 방식     | 특징 요약               |
|--------------|--------------------------------------|------------------|--------------|----------------|--------------------------|
| `[]` 리스트  | `[x * 2 for x in range(5)]`          | 즉시 전체 실행   | 높음         | 한 번에 생성   | 결과를 즉시 모두 계산     |
| `()` 제너레이터 | `(x * 2 for x in range(5))`        | 필요할 때 실행   | 낮음         | 하나씩 생성    | 지연 실행, 메모리 효율적  |
| `map()`      | `map(lambda x: x*2, range(5))`       | 필요할 때 실행   | 낮음         | 하나씩 생성    | 함수 기반 지연 처리       |
| `filter()`   | `filter(lambda x: x > 2, range(5))`  | 필요할 때 실행   | 낮음         | 조건 만족 시 생성 | 조건 기반 지연 처리       |
| `dict{}`     | `{x: x*2 for x in range(5)}`         | 즉시 전체 실행   | 높음         | 한 번에 생성   | 키-값 쌍 즉시 생성         |
| `set{}`      | `{x*2 for x in range(5)}`            | 즉시 전체 실행   | 높음         | 한 번에 생성   | 중복 제거된 값 즉시 생성   |



## 🧠 핵심 차이: 즉시 vs 지연 실행
- [], {} → 즉시 실행: 모든 값을 한 번에 계산하고 저장
- (), map(), filter() → 지연 실행: 값을 꺼낼 때마다 계산

## ✅ 실무에서의 선택 기준
| 상황                         | 추천 표현식              |
|------------------------------|---------------------------|
| 데이터가 작고 빠르게 써야 함 | `[]`, `{}` (즉시 실행)   |
| 데이터가 크거나 스트리밍됨   | `map()`, `filter()`, `()` (지연 실행) |

----

# 🔁 C++: 즉시 vs 지연 실행
## ✅ 즉시 실행
- std::vector, std::map, std::set 등 STL 컨테이너는 즉시 실행
- std::transform, std::copy, std::accumulate 등은 즉시 결과 생성
```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
std::vector<int> doubled;
std::transform(v.begin(), v.end(), std::back_inserter(doubled), [](int x) { return x * 2; });
```

→ 모든 결과가 즉시 계산되어 doubled에 저장됨

## ✅ 지연 실행 (Lazy Evaluation)
- C++20부터 ranges 라이브러리로 지연 실행 가능
- views::transform, views::filter 등은 lazy
```cpp
#include <ranges>
auto lazy_view = std::views::iota(1, 10)
               | std::views::filter([](int x) { return x % 2 == 0; })
               | std::views::transform([](int x) { return x * 3; });
```

→ lazy_view는 실제로 반복할 때만 계산됨



## 단계별 실행 절차
아래는 C++20의 std::ranges를 활용한 lazy_view를 main 함수에서 호출하고 결과가 처리되는 방식을 단계별로 설명한 예제.

## ✅ 전체 코드 예시
```cpp
#include <iostream>
#include <ranges>

int main() {
    auto lazy_view = std::views::iota(1, 10)
                   | std::views::filter([](int x) { return x % 2 == 0; })
                   | std::views::transform([](int x) { return x * 3; });

    for (int val : lazy_view) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
}
```

## 🔍 실행 흐름 설명
### 1. std::views::iota(1, 10)
- 생성: 1, 2, 3, ..., 9 → lazy range (아직 계산 안 됨)
### 2. filter: x % 2 == 0
- 조건: 짝수만 통과 → 2, 4, 6, 8
### 3. transform: x * 3
- 변환: 6, 12, 18, 24
### 4. for 루프에서 값 꺼낼 때마다
- iota → filter → transform → val 생성
- 하나씩 계산됨 (lazy evaluation)

### 🧠 결과 출력
```
6 12 18 24
```

## ✅ 핵심 요약
| 단계         | 설명                                      |
|--------------|-------------------------------------------|
| 선언         | `lazy_view`는 계산되지 않은 파이프라인       |
| 반복 시작    | `for` 루프에서 값 하나씩 꺼낼 때 계산 시작   |
| 처리 흐름    | `iota` → `filter` → `transform` → 출력       |
| 실행 시점    | 반복자가 요청될 때마다 지연 실행됨           |


---

# 🦀 Rust: 즉시 vs 지연 실행
## ✅ 즉시 실행
- vec![], HashMap, HashSet 등은 즉시 생성
- collect() 호출 시 전체 결과를 메모리에 저장
```rust
let v = vec![1, 2, 3, 4, 5];
let doubled: Vec<_> = v.iter().map(|x| x * 2).collect(); // 즉시 실행
```

## ✅ 지연 실행
- iter(), map(), filter()는 모두 lazy
- collect()를 호출하기 전까지는 아무 것도 계산되지 않음
```rust
let lazy = (1..10)
    .filter(|x| x % 2 == 0)
    .map(|x| x * 3); // lazy iterator

for val in lazy {
    println!("{}", val); // 이 시점에 계산됨
}
```

## 🧠 요약 비교
| 언어   | 즉시 실행 예시                        | 지연 실행 예시                             |
|--------|----------------------------------------|---------------------------------------------|
| Python | `[x*2 for x in range(5)]`              | `(x*2 for x in range(5))`                   |
| C++    | `std::vector`, `std::transform`        | `std::views::transform`, `std::views::filter` |
| Rust   | `.collect()`                           | `.iter().map().filter()`                    |


---
