# id & is

## 🧠 변수와 객체 id (id() 함수)
Python에서 변수는 **객체를 참조하는 이름(label)**일 뿐입니다. 실제 값은 메모리에 객체로 존재하고, 변수는 그 객체의 **참조(reference)**를 가리킵니다.

### 🔍 예시 분석
```python
n = 777
m = n
print(id(n), id(m))  # 같은 객체를 참조
```

- m = n은 n이 참조하는 객체를 m도 참조하게 함
- id(n) == id(m) → True (같은 객체)

```python
n = 700
m = 700
print(id(n), id(m))  # 여전히 같은 객체
```

- Python은 작은 정수 객체를 내부적으로 캐싱합니다 (보통 -5 ~ 256)
- 700도 일부 구현에서는 같은 객체로 처리될 수 있음
```python
m = 123.45
n = 123.45
print(id(m), id(n))  # 부동소수점도 같은 객체일 수 있음
```

- 부동소수점은 캐싱되지 않지만, 같은 리터럴을 사용하면 컴파일러 최적화로 인해 같은 객체가 될 수 있음

### 🧾 변수 선언 스타일

| 스타일 이름 | 용도 | 예시 |
|-------------|------|------|
| Camel Case  | 메서드, 일반 변수 | `numberOfCollegeGraduates` |
| Pascal Case | 클래스 이름 | `NumberOfCollegeGraduates` |
| Snake Case  | 함수, 변수 | `number_of_college_graduates` |



### 🚫 예약어 (Reserved Keywords)
Python에는 문법적으로 특별한 의미를 가진 단어들이 있으며, 변수명으로 사용할 수 없습니다.
❗ 사용 불가 예시
```python
for = 1      # ❌ SyntaxError
class = 3    # ❌ SyntaxError
```


### ✅ 예약어 목록
```python
False, def, if, raise,
None, del, import, return,
True, elif, in, try,
and, else, is, while,
as, except, lambda, with,
assert, finally, nonlocal, yield,
break, for, not,
class, from, or, continue, global, pass
```

### 👉 이 목록은 keyword 모듈을 통해 확인할 수 있어요:
```python
import keyword
print(keyword.kwlist)
```


## 📌 요약
- id()는 객체의 고유 메모리 주소를 반환
- 변수는 객체를 참조하는 이름일 뿐
- Python은 일부 객체(작은 정수 등)를 캐싱하여 메모리 효율을 높임
- 변수명은 스타일에 따라 목적이 다름 (클래스, 함수, 일반 변수 등)
- 예약어는 절대 변수명으로 사용 불가
---

# id / reference
Python에서 **객체의 ID와 참조(reference)**가 어떻게 동작하는지를 보여주는 설명.  
아래에 개념과 동작 원리, 실무에서 주의할 점까지 정리.

## 🧠 핵심 개념: id()와 is

| 항목         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| `id(obj)`    | 객체의 고유 식별자(메모리 주소)를 반환. 동일 객체는 같은 `id`를 가짐     |
| `is`         | 두 객체가 **같은 메모리 주소**를 참조하는지 비교. 즉, 객체 동일성 검사     |
| `==`         | 두 객체의 **값이 같은지** 비교. 객체가 달라도 값이 같으면 True가 될 수 있음 |
| 인터닝       | Python이 불변 객체(`int`, `str`, `tuple`)를 재사용하여 `is`가 True가 되는 현상 |
| 실무 사용법  | `is`는 `None`, 싱글톤 객체 비교에만 사용. 일반 값 비교에는 `==` 사용 권장     |


## 🔍 예제 분석
### 🔢 정수 객체
```python
i = 3000
a = 3000
print(id(i), id(a))      # 같은 ID
print(i is a)            # True
```

- 정수 3000은 일반적으로 새 객체로 생성되지만, Python은 같은 값의 객체를 재사용할 수 있음
- 특히 작은 정수(-5 ~ 256)는 인터닝(interning) 되어 항상 같은 객체를 참조함
- 여기서 3000도 최적화에 의해 같은 객체로 처리됨 (구현체에 따라 다를 수 있음)
### 🔤 문자열 객체
```python
s1 = "abc"
s2 = "abc"
print(id(s1), id(s2))    # 같은 ID
print(s1 is s2)          # True
```

- 문자열 "abc"는 **불변(immutable)**이고, Python은 문자열 인터닝을 통해 같은 객체를 재사용함
- 그래서 s1 is s2는 True

### 🧪 실험 확장: 일부 값은 다르게 동작함
```python
x = 10_000_000
y = 10_000_000
print(x is y)  # False일 수도 있음 (인터닝 안 됨)
```

- 큰 숫자나 복잡한 객체는 인터닝되지 않아 is 비교 시 False가 나올 수 있음


## 🧠 실무에서 주의할 점

| 상황 또는 항목             | 설명                                                                 |
|----------------------------|----------------------------------------------------------------------|
| `is` vs `==` 구분 필요      | `is`는 객체 동일성, `==`는 값 비교. 값이 같아도 객체가 다르면 `is`는 False |
| 인터닝 최적화              | 작은 정수(`-5~256`)와 짧은 문자열은 인터닝되어 `is` 비교도 True가 될 수 있음 |
| 큰 숫자나 복잡한 객체       | 인터닝되지 않으므로 `is` 비교는 False가 나올 수 있음                     |
| `is`는 참조 비교에만 사용   | `None`, 싱글톤 객체 비교처럼 객체 자체를 비교할 때만 `is` 사용해야 안전함   |
| 불변 객체(str, int, tuple) | 인터닝 대상이 될 수 있어 같은 값을 가진 객체가 동일한 참조를 가질 수 있음   |



## ✅ 정리
- id()는 객체의 메모리 주소를 확인하는 도구
- is는 두 객체가 정말 같은 객체인지를 확인하는 연산자
- Python은 불변 객체에 대해 인터닝 최적화를 수행함
- 실무에서는 is는 None 비교나 싱글톤 객체에만 사용하는 것이 안전함


## 실제 소스
```python
i = 3000
a = 3000
print(id(i), id(a))
'''2935939919696 2935939919696'''


print(i is a)
'''True'''

s1 = "abc"
s2 = "abc"
print(id(s1), id(s2))
'''140733992672832 140733992672832'''

print(s1 is s2)
'''True'''
```
