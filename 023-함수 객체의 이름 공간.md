 ## 함수 객체의 이름 공간이란

- Python에서 함수는 **일급 객체(first-class object)**입니다.
- 즉, 변수에 할당하거나, 인자로 전달하거나, 속성을 추가할 수 있는 객체입니다.
- 함수 객체는 내부적으로 __dict__라는 이름 공간을 가지고 있어, 여기에 사용자 정의 속성을 저장할 수 있습니다.

## 📌 샘플 코드 설명
### ❌ 오류 발생 예시
```python
def func(x, y):
    func.sum = func.sum + x + y
    return x + y

func(1, 5)  # AttributeError 발생
```

- func.sum이 정의되지 않았기 때문에 AttributeError가 발생합니다.

### ✅ 속성 초기화 후 사용
```python
func.sum = 0
func(1, 5)
print(func.__dict__)  # {'sum': 6}

```
- func.sum을 먼저 정의하면 함수 내부에서 접근 가능.
- func.__dict__를 통해 함수 객체의 속성을 확인할 수 있습니다.

### ✅ 내부에서 안전하게 초기화
```python
def func1(x, y):
    if not hasattr(func1, 'sum'):
        func1.sum = 0
    func1.sum += x + y
    return x + y
```

- hasattr로 속성 존재 여부를 확인하고 초기화하면 안전하게 사용할 수 있습니다.



## ✅ 실용적인 예제: 함수 객체를 활용한 상태 저장

### 1. 📊 API 호출 횟수 추적기
```python
def api_call(endpoint):
    if not hasattr(api_call, 'count'):
        api_call.count = 0
    api_call.count += 1
    print(f"[{api_call.count}] Calling {endpoint}")

api_call("/users")
api_call("/posts")
print(api_call.__dict__)  # {'count': 2}
```


### 2. 🧮 누적 합 계산기
```python
def accumulator(value):
    if not hasattr(accumulator, 'total'):
        accumulator.total = 0
    accumulator.total += value
    return accumulator.total

print(accumulator(10))  # 10
print(accumulator(5))   # 15
print(accumulator.__dict__)  # {'total': 15}
```

### 3. 🧪 테스트 케이스 통계 수집기
```python
def test_case(name, passed):
    if not hasattr(test_case, 'results'):
        test_case.results = {'pass': 0, 'fail': 0}
    if passed:
        test_case.results['pass'] += 1
    else:
        test_case.results['fail'] += 1
    print(f"Test {name}: {'PASS' if passed else 'FAIL'}")

test_case("Login", True)
test_case("Signup", False)
print(test_case.__dict__)  # {'results': {'pass': 1, 'fail': 1}}
```


## ⚠️ 주의사항
- 함수 객체에 상태를 저장하는 방식은 간단하고 유용하지만, 멀티스레드 환경이나 함수 재사용 시에는 **부작용(side effect)**이 발생할 수 있습니다.
- 더 안전한 방식은 클래스나 클로저(closure)를 사용하는 것입니다.

## 🔚 마무리
함수 객체의 이름 공간을 활용하면 간단한 상태 추적, 누적 계산, 통계 수집 등을 함수 내부에서 처리할 수 있어 실무에서도 유용합니다. 하지만 복잡한 로직이나 병렬 처리 환경에서는 클래스를 사용하는 것이 더 안전합니다.
원하시면 이 개념을 클래스나 데코레이터로 확장한 예제도 만들어드릴게요!


## 🧱 1. 클래스 기반 확장: 상태 추적기
클래스는 상태를 관리하기에 가장 적합한 구조입니다. 함수 객체에 속성을 붙이는 대신, 클래스의 인스턴스 변수로 상태를 관리하면 가독성, 확장성, 테스트성이 모두 향상됩니다.

## ✅ 예제: 누적 합 계산기
```python
class Accumulator:
    def __init__(self):
        self.total = 0

    def add(self, x, y):
        result = x + y
        self.total += result
        return result

# 사용 예
acc = Accumulator()
print(acc.add(1, 5))  # 6
print(acc.add(2, 3))  # 5
print(acc.total)      # 11
```

## 💼 실무 활용: API 호출 횟수 추적기
```python
class APICounter:
    def __init__(self):
        self.count = 0

    def call(self, endpoint):
        self.count += 1
        print(f"[{self.count}] Calling {endpoint}")

api = APICounter()
api.call("/users")
api.call("/posts")
```



## 🎀 2. 데코레이터 기반 확장: 함수에 상태 주입
데코레이터를 사용하면 기존 함수를 감싸서 상태를 주입하거나 추적할 수 있음.  
함수 객체의 속성을 직접 다루는 것보다 더 깔끔하고 재사용 가능합니다.

### ✅ 예제: 호출 횟수 추적 데코레이터
```python
def call_counter(func):
    func.count = 0

    def wrapper(*args, **kwargs):
        func.count += 1
        print(f"Call #{func.count}")
        return func(*args, **kwargs)

    return wrapper

@call_counter
def greet(name):
    print(f"Hello, {name}!")

greet("JungHwan")
greet("Python")
print(greet.__wrapped__.__dict__)  # {'count': 2}
```

## 🧪 실무 활용: 로깅 데코레이터
```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"[LOG] Calling {func.__name__} with args={args}, kwargs={kwargs}")
        return func(*args, **kwargs)
    return wrapper

@logger
def process_data(data):
    print(f"Processing {data}")

process_data({"id": 1, "value": 42})
```

### 출력 결과
```
[LOG] Calling process_data with args=({'id': 1, 'value': 42},), kwargs={}
Processing {'id': 1, 'value': 42}
```

#### 🔍 설명
- 첫 번째 줄은 logger 데코레이터가 출력하는 로그 메시지입니다.
- func.__name__ → "process_data"
- args → ({'id': 1, 'value': 42},)
- kwargs → {}
- 두 번째 줄은 process_data 함수 본문에서 출력하는 내용입니다.
- print(f"Processing {data}") → Processing {'id': 1, 'value': 42}

## 🔚 마무리 요약

| 방식           | 장점                              | 단점                              | 추천 용도                         |
|----------------|-----------------------------------|-----------------------------------|-----------------------------------|
| 함수 객체 속성 | 간단하고 빠르게 구현 가능          | 유지보수 어려움, 부작용 가능       | 실험적 코드, 간단한 상태 저장     |
| 클래스         | 구조적, 확장성 뛰어남              | 코드 양 증가                       | 실무 로직, API, 계산기 등         |
| 데코레이터     | 재사용 가능, 함수 외부에서 제어 가능 | 복잡한 로직은 관리 어려움          | 로깅, 추적, 인증, 캐싱 등         |

---

# 클로저(closure)

함수 객체의 속성처럼 상태를 저장하는 방식은 간단하지만, **클로저(closure)**를 사용하면 더 안전하고 캡슐화된 방식으로 상태를 유지할 수 있음.  
아래에 클로저의 개념과 실용적인 예제를 정리.

## 🧠 클로저(Closure)란?
클로저는 함수 내부에 정의된 함수가 바깥 함수의 지역 변수에 접근할 수 있는 구조입니다.
즉, 외부 함수의 상태를 내부 함수가 기억하고 사용할 수 있는 함수 객체.


## ✅ 특징
- 외부 함수가 종료되어도 내부 함수는 외부 변수에 접근 가능
- 상태를 은닉하고 유지할 수 있어 안전함
- 객체처럼 동작하지만 클래스보다 가볍고 간결함

## 🧪 기본 클로저 예제: 누적 합 계산기
```python
def make_accumulator():
    total = 0

    def add(x):
        nonlocal total
        total += x
        return total

    return add

acc = make_accumulator()
print(acc(10))  # 10
print(acc(5))   # 15
print(acc(3))   # 18

```

🔍 설명
- total은 make_accumulator의 지역 변수
- add 함수는 total을 기억하고 계속 누적
- nonlocal 키워드는 내부 함수에서 외부 변수 수정 가능하게 함

💼 실무 예제 1: API 호출 횟수 추적기
```python
def api_counter():
    count = 0

    def call(endpoint):
        nonlocal count
        count += 1
        print(f"[{count}] Calling {endpoint}")

    return call

api = api_counter()
api("/users")  # [1] Calling /users
api("/posts")  # [2] Calling /posts

```

##  💼 실무 예제 2: 제한된 호출 횟수 함수
```rust
def limited_executor(limit):
    count = 0

    def execute(task):
        nonlocal count
        if count < limit:
            count += 1
            print(f"Executing: {task}")
        else:
            print("Limit reached!")

    return execute

run = limited_executor(3)
run("Task A")  # Executing: Task A
run("Task B")  # Executing: Task B
run("Task C")  # Executing: Task C
run("Task D")  # Limit reached!
```


## 🔐 클로저 vs 클래스 비교 요약
| 항목       | 클로저                             | 클래스                             | 비고                             |
|------------|------------------------------------|-------------------------------------|----------------------------------|
| 구조       | 함수 내부에 함수 정의               | 명시적 클래스 구조                  | 클로저는 함수형, 클래스는 객체지향 |
| 상태 저장  | 외부 함수의 지역 변수              | 인스턴스 변수                       | `nonlocal` 키워드로 상태 유지     |
| 캡슐화     | 강력 (외부에서 직접 접근 불가)     | 가능하지만 접근 제어는 약함         | 클로저는 은닉성이 뛰어남          |
| 사용 용도  | 간단한 상태 추적, 일회성 로직      | 복잡한 로직, 다중 메서드 필요 시    | 상황에 따라 선택                  |

클로저는 특히 함수형 스타일의 코드, 간단한 상태 추적, 콜백 함수 생성 등에 매우 유용.

----
# 변수 소멸

def limited_executor(limit):
    count = 0

결론부터 말하면, 클로저에서 사용된 변수 count는 외부 함수 limited_executor가 소멸되더라도 내부 함수가 살아 있는 한 함께 소멸되지 않습니다.

## 🔍 왜 그런가요?
클로저는 외부 함수의 실행 컨텍스트(지역 변수 등)를 내부 함수가 캡처(capture)해서 기억하는 구조입니다.
즉, limited_executor 함수가 실행되고 나면 count는 사라지는 게 아니라, 내부 함수 execute가 자신의 환경으로 count를 끌어안고 살아갑니다.
```python
def limited_executor(limit):
    count = 0

    def execute(task):
        nonlocal count
        if count < limit:
            count += 1
            print(f"Executing: {task}")
        else:
            print("Limit reached!")

    return execute
```

### 실행 예시
```python
run = limited_executor(3)
run("A")  # count = 1
run("B")  # count = 2
run("C")  # count = 3
run("D")  # count = 3 → "Limit reached!"
```

- limited_executor는 호출 후 사라지지만,
- run은 execute를 참조하고 있고,
- execute는 count를 자기 클로저 환경에 저장하고 있어서 계속 유지됩니다.

## 🧠 메모리 관점에서
- count는 run 함수 객체의 클로저 환경에 포함된 변수입니다.
- run.__closure__를 확인하면 count가 저장된 셀(cell)을 볼 수 있어요.

```python
print(run.__closure__[0].cell_contents)  # 출력: 현재 count 값

```

## ✅ 클로저 구조 요약

| 변수/함수 | 포함 관계 | 설명                          |
|-----------|------------|-------------------------------|
| count     | execute     | `execute` 함수가 `count`를 캡처함 |
| execute   | run         | `run`은 `execute`를 참조함       |
| count     | run         | `run`이 살아 있는 동안 `count`도 유지됨 |



