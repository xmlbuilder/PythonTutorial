# filling values 

## 1. 전체 코드 다시 보기
```python
import numpy as np
from io import StringIO

data = u"N/A, 2, 3\n4, , ???"
kwargs = dict(
    delimiter=",",
    dtype=int,
    names="a,b,c",
    missing_values={0: "N/A", 'b': " ", 2: "???"},
    filling_values={0: 0, 'b': 0, 2: -999},
)
a = np.genfromtxt(StringIO(data), **kwargs)
print(a)
```
```
[(0, 2,    3) (4, 0, -999)]
```
```python
print(a.dtype)
```
```
[('a', '<i8'), ('b', '<i8'), ('c', '<i8')]
```

### 텍스트:
```
N/A, 2, 3
4, , ???
```

- 이걸 genfromtxt가 **결측값 처리 + 채우기 + 구조화 배열(structured array)** 로 읽어들이는 예제.

## 2. 먼저, 구조화 배열이기 때문에 dtype이 저렇게 나오는 것
```
names="a,b,c"
dtype=int
```

- names="a,b,c"
 - a, b, c라는 필드 이름을 가진 구조화 배열이 된다.
 - 결과 dtype:
  - dtype=int
  - 각 필드의 타입이 정수(int64 = <i8)로 설정된다.
```
[('a', '<i8'), ('b', '<i8'), ('c', '<i8')]
```
- 그래서 a는 일반 2D 배열이 아니라, 이런 식의 **레코드 배열** 이다:

|idx |   a   |   b   |   c   |
|----|-------|-------|-------|
| 0  |   0   |   2   |   3   |
| 1  |   4   |   0   | -999  |



## 3. missing_values와 filling_values가 하는 일
- 핵심은 이 두 개:
```python
missing_values={0: "N/A", 'b': " ", 2: "???"},
filling_values={0: 0, 'b': 0, 2: -999},
```

### 3.1 공통 아이디어
- missing_values:
 - **이 문자열이 나오면 결측값(missing) 으로 간주한다**
- filling_values:
 - **결측값이면 이 숫자로 채움**
- 여기서 포인트는 키(key) 를 두 가지 방식으로 쓸 수 있다는 것.
 - 열 인덱스(0, 1, 2, …)
 - 필드 이름('a', 'b', 'c', …)
- 둘을 섞어서 쓴 예제.

### 3.2 이 예제에서의 설정 해석
```python
sing_values={
    0: "N/A",   # 0번 컬럼(= a 필드)에서 "N/A"는 결측값
    'b': " ",   # b 필드에서 " " (공백 하나)는 결측값
    2: "???"    # 2번 컬럼(= c 필드)에서 "???" 는 결측값
}

filling_values={
    0: 0,       # 0번 컬럼(a)의 결측값은 0으로 채움
    'b': 0,     # b 필드의 결측값도 0으로 채움
    2: -999     # 2번 컬럼(c)의 결측값은 -999로 채움
}
```

- 즉, 열 기준으로보면:
    - 컬럼 0 (a 필드)
        - "N/A" → 결측 → 0으로 채움
    - 컬럼 1 (b 필드)
        - " " (공백) → 결측 → 0으로 채움
    - 컬럼 2 (c 필드)
        - "???" → 결측 → -999로 채움
    - 이 규칙을 각 행에 적용한다.

## 4. 각 줄이 어떻게 변환되는지
### 4.1 첫 번째 줄: "N/A, 2, 3"
- 컬럼 0 (a): "N/A"
    - missing_values[0] == "N/A" → 결측으로 판단
    - filling_values[0] == 0 → 0으로 채움
- 컬럼 1 (b): " 2" (공백 + 2)
    - 공백을 제거하고 "2"로 읽힘 → 정상 정수 2
    - 컬럼 2 (c): " 3"
- "3" → 정상 정수 3
- 그래서 첫 번째 레코드:
```
(a, b, c) = (0, 2, 3)
```

### 4.2 두 번째 줄: "4, , ?줄
- 컬럼 0 (a): "4"
    - 결측이 아님 → 4
- 컬럼 1 (b): " " (쉼표 사이에 공백만 있음)
    - missing_values['b'] == " " → 결측
    - filling_values['b'] == 0 → 0으로 채움
- 컬럼 2 (c): " ???"
    - "???" → missing_values[2] == "???" → 결측
    - filling_values[2] == -999 → -999로 채움
- 그래서 두 번째 레코드:
```
(a, b, c) = (4, 0, -999)
```


## 5. 최종 결과 해석
- 배열 값
```python
print(a)
```
```
[(0, 2,    3) (4, 0, -999)]
```

- 2개의 레코드(record)가 있는 1D 구조화 배열
- 각 레코드는 (a, b, c) 형식의 튜플
- dtype
```python
print(a.dtype)
```
```
[('a', '<i8'), ('b', '<i8'), ('c', '<i8')]
```

- 필드 이름: a, b, c
- 각 필드 타입: 정수 8바이트 (<i8)
- 그래서 이런 식으로 접근 가능:
```python
a['a']  # array([0, 4])
a['b']  # array([2, 0])
a['c']  # array([   3, -999])
```

## 6. 정리해보면
- names="a,b,c" → 구조화 배열 생성 (필드: a, b, c)
- missing_values → **어떤 문자열을 결측값으로 볼지**  열별로 지정
- filling_values → **결측값이면 어떤 숫자로 채울지** 열별로 지정
- 텍스트 "N/A, 2, 3\n4, , ???"에
    - "N/A" → 0번 컬럼 → 결측 → 0
    - " " → b 컬럼 → 결측 → 0
    - "???" → 2번 컬럼 → 결측 → -999
- 를 적용해서
    - [(0, 2, 3), (4, 0, -999)] 가 만들어짐.


 ---
 



