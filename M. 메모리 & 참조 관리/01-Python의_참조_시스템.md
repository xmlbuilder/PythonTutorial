# 🧠 Python의 참조 시스템

- Python은 모든 값을 객체로 다루고, 변수는 객체를 직접 저장하는 게 아니라 참조.  
- 이 참조는 객체의 **생명 주기, 메모리 관리, GC(가비지 컬렉션)** 에 깊이 관여.

## 🔗 참조의 종류

| 참조 종류           | 설명                                                                 |
|----------------------|----------------------------------------------------------------------|
| 강한 참조            | 일반적인 변수 할당. 참조 카운트를 증가시키며 객체 생존에 직접 영향         |
| 약한 참조 (`weakref.ref()`)| 참조 카운트를 증가시키지 않음. 객체가 삭제되면 `None` 반환                    |
| 순환 참조            | 두 객체가 서로를 참조할 때 발생. 참조 수가 0이 아니어도 GC가 필요함         |
| 내부 참조            | 리스트, 딕셔너리, 클래스 속성 등 내부 구조에서 발생하는 참조               |
| 전역 참조            | 모듈 수준에서 유지되는 참조. 프로그램 종료 전까지 살아 있음               |
| 클로저 참조          | 함수 내부에서 외부 스코프의 변수를 참조할 때 발생                         |
| 캐시 참조 (`WeakValueDictionary`) | 객체가 삭제되면 자동으로 캐시에서 제거됨. 메모리 누수 방지에 유용             |

## 🔍 강한 참조 vs 약한 참조
### ✅ 강한 참조 (기본)
```python
obj = Reference("A", 18)  # 강한 참조
```

- obj는 Reference 객체를 강하게 참조
- sys.getrefcount(obj)로 참조 수 확인 가능
- 참조 수가 0이 되면 객체는 GC 대상이 됨

### ✅ 약한 참조 (weakref)
```python
import weakref
r = weakref.ref(obj)  # 약한 참조
```

- r()로 객체에 접근 가능
- 객체가 삭제되면 r()은 None 반환
- 참조 수를 증가시키지 않음 → GC에 영향 없음

### 🧪 실무 예제 흐름 분석
```python
a = Reference("A", 18)      # 강한 참조
r = weakref.ref(a)          # 약한 참조 생성
a2 = r()                    # 강한 참조로 다시 복원
del a                       # 원래 강한 참조 제거
gc.collect()                # GC 실행
```

- a2가 살아 있는 동안 객체는 삭제되지 않음
- a2 제거 후 r()은 None 반환 → 객체가 GC에 의해 제거됨


### 🧠 참조 추적 핵심 요약

| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 객체 참조 시스템    | Python은 모든 객체를 참조 기반으로 관리하며, 참조 수가 0이 되면 GC 대상이 됨 |
| `sys.getrefcount()`| 특정 객체의 현재 참조 수를 반환함. 디버깅과 메모리 누수 분석에 유용       |
| 강한 참조          | 일반 변수 할당, 리스트/딕셔너리 포함 등 참조 수를 증가시키는 모든 구조       |
| 약한 참조 (`weakref`)| 참조 수를 증가시키지 않음. 객체가 삭제되면 `None` 반환                    |
| 순환 참조          | 서로 참조하는 객체들로 인해 참조 수가 0이 아니어도 GC가 필요함              |

### 🧠 참고 함수 요약

| 함수              | 설명                                                                 |
|-------------------|----------------------------------------------------------------------|
| `sys.getrefcount()`| 특정 객체의 현재 참조 수를 반환함. 디버깅, 메모리 누수 분석에 유용         |
| `gc.collect()`     | 가비지 컬렉션을 강제로 실행함. 순환 참조나 미사용 객체를 명시적으로 제거 가능 |
| `weakref.ref()`    | 약한 참조 객체를 생성함. 참조 수를 증가시키지 않아 GC 대상이 될 수 있음     |


# 실무에서 사용
- 실무에서는 꽤 구체적인 문제 해결에 쓰임. 
- 아래에 각 참조 종류가 왜 필요한지, 그리고 실제 어떻게 쓰이는지를 샘플과 함께 정리.

## 🔗 참조의 종류: 실무 활용과 샘플
### ✅ 1. 강한 참조 (Strong Reference)

### 왜 쓰나?
- 기본적인 객체 생존 방식. 대부분의 코드에서 객체를 유지하려면 강한 참조가 필요.

#### 샘플
```python
class User:
    pass

u = User()  # 강한 참조
```

#### 실무 활용
- 객체를 명시적으로 유지하고 싶을 때
- 리스트, 딕셔너리 등에 저장할 때

###  ✅ 2. 약한 참조 (Weak Reference)
### 왜 쓰나?
객체를 참조하되, GC에 의해 자동 제거되도록 하고 싶을 때. 캐시, 이벤트 핸들러, 리스너 등에 유용.

#### 샘플
```python
import weakref

class Model:
    pass

m = Model()
r = weakref.ref(m)  # 약한 참조
print(r())  # <__main__.Model object at ...>
del m
print(r())  # None
```

- 실무 활용
    - 캐시 시스템: 객체가 삭제되면 캐시에서도 자동 제거됨
    - GUI 이벤트 핸들러: 메모리 누수 방지
    - 객체 생존 여부 추적

### ✅ 3. 순환 참조 (Circular Reference)
### 왜 쓰나?
- 의도하지 않게 발생하는 경우가 많고, GC가 없으면 메모리 누수로 이어질 수 있음.
#### 샘플
```python
class A:
    def __init__(self):
        self.b = None

class B:
    def __init__(self):
        self.a = None
```
```python
a = A()
b = B()
a.b = b
b.a = a  # 순환 참조
```

#### 실무 활용
- ORM 모델 간 관계 설정
- 트리 구조, 그래프 구조
- 반드시 gc.collect()로 관리 필요

### ✅ 4. 클로저 참조 (Closure Reference)
### 왜 쓰나?
- 함수형 프로그래밍이나 콜백에서 외부 변수를 유지하고 싶을 때.

#### 샘플
```python
def outer():
    x = 10
    def inner():
        return x  # 클로저 참조
    return inner

f = outer()
print(f())  # 10
```

#### 실무 활용
- 비동기 콜백
- 데코레이터
- 상태 유지형 함수

### ✅ 5. 캐시 참조 (WeakValueDictionary)
### 왜 쓰나?
- 객체가 삭제되면 캐시에서도 자동 제거됨. 메모리 누수 방지에 탁월.

#### 샘플

```python
import weakref

class Data:
    pass

cache = weakref.WeakValueDictionary()
d = Data()
cache['key'] = d
print(cache['key'])  # <__main__.Data object at ...>
del d
print('key' in cache)  # False
```

#### 실무 활용
- 이미지, 모델, 세션 객체 캐싱
- LRU 캐시 구현
- 메모리 최적화

### 🧠 왜 중요한가?

| 문제 상황             | 해결 방법 또는 관련 참조 방식                         |
|----------------------|--------------------------------------------------------|
| 객체 생존 여부 추적    | `weakref`를 사용하면 객체가 살아 있는지 확인 가능         |
| 캐시 자동 정리        | `WeakValueDictionary`는 객체가 삭제되면 캐시에서도 제거됨 |
| 메모리 누수 방지       | 약한 참조를 사용하면 이벤트 핸들러, 리스너 누적을 방지 가능 |
| 순환 참조로 인한 GC 실패 | `gc.collect()`로 해결 가능. 참조 구조를 설계할 때 주의 필요   |
| 테스트 중 객체 추적    | `sys.getrefcount()`로 참조 수 확인하여 누수 여부 파악 가능   |

---

# 강한 참조 설명

- 우리가 클래스 인스턴스를 만들고 변수에 담는 순간, 그 변수는 해당 객체에 대한 **강한 참조(strong reference)** 를 갖게 됨.  
- 이건 Python의 메모리 관리에서 아주 중요한 개념.

## 🔗 강한 참조란?
- 객체의 **참조 카운트(refcount)** 를 증가시키는 참조 방식
- 객체가 GC(가비지 컬렉션) 대상이 되지 않도록 생존을 보장함
- 대부분의 Python 코드에서 사용하는 기본 참조 방식

## 🧪 예시로 다시 보면
```python
class Reference:
    def __init__(self, name, age):
        self.name = name
        self.age = age

a = Reference("A", 18)  # ← 여기서 a는 강한 참조
```

- a는 Reference("A", 18) 객체를 강하게 붙잡고 있음
- sys.getrefcount(a)를 찍어보면 참조 수가 2 이상인 이유는:
    - 하나는 a 자체
    - 하나는 getrefcount() 함수 내부에서 임시로 참조하기 때문

### 🧠 실무에서 왜 중요하냐면…

| 상황 또는 문제점         | 참조 관리로 해결할 수 있는 이유                                  |
|--------------------------|-------------------------------------------------------------------|
| 객체 생존 여부 추적       | `weakref`를 사용하면 객체가 살아 있는지 확인 가능. GC 대상 여부 판단에 유용 |
| 캐시 자동 정리           | `WeakValueDictionary`는 객체가 삭제되면 캐시에서도 자동 제거됨. 메모리 누수 방지 |
| 이벤트 핸들러 누적 방지    | GUI나 비동기 시스템에서 약한 참조로 등록하면 핸들러가 자동 해제됨               |
| 순환 참조로 인한 메모리 누수 | `gc.collect()`로 순환 참조를 제거 가능. 참조 구조 설계 시 주의 필요               |
| 테스트 중 객체 추적       | `sys.getrefcount()`로 참조 수 확인하여 객체가 예상대로 관리되고 있는지 검증 가능   |

### 🔍 강한 참조 vs 약한 참조

| 항목               | 강한 참조                                      | 약한 참조 (`weakref`)                          |
|--------------------|-----------------------------------------------|------------------------------------------------|
| 참조 카운트 영향     | ✅ 증가시킴                                     | ❌ 증가시키지 않음                              |
| 객체 생존 여부       | 참조가 남아 있는 한 객체는 GC 대상이 아님         | 참조만으로는 객체 생존 보장 안 됨               |
| GC(가비지 컬렉션) 영향| 참조 수가 0이 되어야 GC 대상이 됨                 | 객체가 삭제되면 참조는 자동으로 `None` 반환     |
| 사용 목적           | 일반적인 변수 할당, 객체 유지                    | 캐시, 이벤트 핸들러, 생존 여부 추적, 메모리 최적화 |
| 실무 활용 예시       | 리스트, 딕셔너리, 클래스 속성 등에서 객체 저장     | `WeakValueDictionary`, GUI 핸들러, 캐시 시스템   |

---






