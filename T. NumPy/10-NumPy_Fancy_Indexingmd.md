# Basic — Fancy Indexing & Index Tricks


## ✅ 1. 기본 인덱싱 예제
```python
import numpy as np

a = np.arange(12) ** 2
# → [  0   1   4   9  16  25  36  49  64  81 100 121]

i = np.array([1, 1, 3, 8, 5])
c = a[i]
# → [ 1  1  9 64 25]

j = np.array([[3, 4], [9, 7]])
d = a[j]
# → [[ 9 16]
#    [81 49]]
```
##  ✅ 2. 색상 팔레트 인덱싱
```python
palette = np.array([
    [0, 0, 0],       # black
    [255, 0, 0],     # red
    [0, 255, 0],     # green
    [0, 0, 255],     # blue
    [255, 255, 255], # white
])

image = np.array([
    [0, 1, 2, 0],
    [0, 3, 4, 0]
])

d = palette[image]
# → shape: (2, 4, 3)
# → 각 픽셀을 RGB 색상으로 매핑

'''
[[[  0   0   0]
  [255   0   0]
  [  0 255   0]
  [  0   0   0]]
 [[  0   0   0]
  [  0   0 255]
  [255 255 255]
  [  0   0   0]]]
'''

```


### ✅ 3. 다차원 인덱싱
```python
a = np.arange(12).reshape(3, 4)
# → [[ 0  1  2  3]
#    [ 4  5  6  7]
#    [ 8  9 10 11]]

i = np.array([[0, 1], [1, 2]])
j = np.array([[2, 1], [3, 3]])
d = a[i, j]
# → [[ 2  5]
#    [ 7 11]]

d = a[i, 2]
# → [[ 2  6]
#    [ 6 10]]

d = a[:, j]
# → shape: (3, 2, 2)
# → 각 행에서 j 위치의 값 추출
```

### 결과:
```
# [[[ 2  1]
#   [ 3  3]]
#  [[ 6  5]
#   [ 7  7]]
#  [[10  9]
#   [11 11]]]
```

## ✅ 4. 최대값 위치 인덱싱

```python
time = np.linspace(20, 145, 5)

# [ 20.    51.25  82.5  113.75 145.  ]

data = np.sin(np.arange(20).reshape(5, 4))
# shape: (5, 4)
'''
[[ 0.          0.84147098  0.90929743  0.14112001]
 [-0.7568025  -0.95892427 -0.2794155   0.6569866 ]
 [ 0.98935825  0.41211849 -0.54402111 -0.99999021]
 [-0.53657292  0.42016704  0.99060736  0.65028784]
 [-0.28790332 -0.96139749 -0.75098725  0.14987721]]
'''

ind = data.argmax(axis=0)
# 각 열에서 최대값 위치
'''[2 0 3 1]'''

time_max = time[ind]
# 최대값이 발생한 시간
'''[ 82.5   20.   113.75  51.25]'''

data_max = data[ind, range(data.shape[1])]
# 최대값 직접 추출
'''[0.98935825 0.84147098 0.99060736 0.6569866 ]'''
np.all(data_max == data.max(axis=0))
# True (검증)
'''True'''
```

## ✅ 5. 인덱싱을 통한 값 변경
```python
a = np.arange(5)
# [0 1 2 3 4]

a[[1, 3, 4]] = 0
# [0 0 2 0 0]

a = np.arange(5)
a[[0, 0, 2]] = [1, 2, 3]
# [2 1 3 3 4]

a = np.arange(5)
a[[0, 0, 2]] += 1
# [1 1 3 3 4]
# 중복 인덱스는 한 번만 처리됨 (주의!)
```

----

# NumPy의 다차원 Fancy Indexing을 활용한 고급 인덱싱 기법. 
아래에 각 단계별로 배열의 구조, 인덱싱 방식, 그리고 결과가 어떻게 나오는지를 하나하나 설명.

## ✅ Step 1: 배열 생성
```python
a = np.arange(12).reshape(3, 4)
```

- np.arange(12) → [0, 1, 2, ..., 11]
- .reshape(3, 4) → 3행 4열로 재배열
```python
a =
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

```

## ✅ Step 2: 다차원 인덱싱 — a[i, j]
```python
i = np.array([[0, 1], [1, 2]])
j = np.array([[2, 1], [3, 3]])
d = a[i, j]


i = [[0, 1],
     [1, 2]]

j = [[2, 1],
     [3, 3]]
```


- i와 j는 같은 shape (2, 2)
- a[i, j]는 (i[k], j[k]) 위치의 값을 추출

| i 값 | j 값 | 위치      | a[i, j] 값 |
|------|------|-----------|------------|
| 0    | 2    | a[0, 2]   | 2          |
| 1    | 1    | a[1, 1]   | 5          |
| 1    | 3    | a[1, 3]   | 7          |
| 2    | 3    | a[2, 3]   | 11         |

### 결과:
```
d =
[[ 2  5]
 [ 7 11]]
```


## ✅ Step 3: 브로드캐스팅 인덱싱 — a[i, 2]
```python
d = a[i, 2]

i = [[0, 1],
     [1, 2]]
```


- i.shape = (2, 2)
- 2는 스칼라 → 브로드캐스트됨
즉, 각 i[k]에 대해 a[i[k], 2]를 계산:
| i[k] | 열 인덱스 | 위치      | a[i[k], 2] 값 |
|------|-----------|-----------|---------------|
| 0    | 2         | a[0, 2]   | 2             |
| 1    | 2         | a[1, 2]   | 6             |
| 1    | 2         | a[1, 2]   | 6             |
| 2    | 2         | a[2, 2]   | 10            |



### 결과:
```
d =
[[ 2  6]
 [ 6 10]]
```


### ✅ Step 4: 다차원 인덱싱 — a[:, j]
```python
d = a[:, j]

j = [[2, 1],
     [3, 3]]

```

- : → 모든 행 (0, 1, 2)
- j.shape = (2, 2) → 각 행에 대해 동일한 인덱스 j 적용
즉, 각 행 r에 대해 a[r, j]를 수행:

| 행 r | j[0] = [`2`, `1`] | j[1] = [`3`, `3`] | 결과 행                         |
|------|---------------|---------------|----------------------------------|
| 0    | a[0, `2`] = 2   | a[0, `1`] = 1   | [2 1], a[0, `3`] = 3, a[0, `3`] = 3 → [3 3] |
| 1    | a[1, `2`] = 6   | a[1, `1`] = 5   | [6 5], a[1, `3`] = 7, a[1, `3`] = 7 → [7 7] |
| 2    | a[2, `2`] =10   | a[2, `1`] = 9   | [10 9], a[2, `3`] =11, a[2, `3`] =11 → [11 11] |




### 결과:
```
d =
[[[ 2  1]
  [ 3  3]]

 [[ 6  5]
  [ 7  7]]

 [[10  9]
  [11 11]]]
```

- shape: (3, 2, 2) → 3행 × j의 shape

### 🧠 핵심 요약
| 표현       | 동작 방식                                      | 결과 형태 및 설명                          |
|------------|------------------------------------------------|--------------------------------------------|
| a[i, j]    | i[k], j[k] 쌍으로 좌표 접근                    | shape = i.shape, 각 (i[k], j[k]) 위치의 값 |
| a[i, 2]    | i[k]에 대해 열 인덱스 2를 고정하여 추출        | shape = i.shape, 각 행에서 열 2의 값       |
| a[:, j]    | 모든 행에 대해 j 배열을 브로드캐스트하여 추출   | shape = (행 수, j.shape), 행마다 j 위치의 값 |


## 🔧 예시 요약
```python
a = np.arange(12).reshape(3, 4)
# → [[ 0  1  2  3]
#    [ 4  5  6  7]
#    [ 8  9 10 11]]

i = [[0, 1], [1, 2]]
j = [[2, 1], [3, 3]]

a[i, j]    → [[ 2  5], [ 7 11]]
a[i, 2]    → [[ 2  6], [ 6 10]]
a[:, j]    → [[[ 2  1], [ 3  3]], [[ 6  5], [ 7  7]], [[10  9], [11 11]]]

```









