## 🧠 Shallow Copy vs Deep Copy 개념

| 항목             | Shallow Copy (얕은 복사)                     | Deep Copy (깊은 복사)                        |
|------------------|----------------------------------------------|----------------------------------------------|
| 복사 범위         | 바깥쪽 객체만 복사, 내부 객체는 참조 공유       | 바깥쪽 + 내부 객체 모두 새로 복사             |
| 메모리 주소       | 내부 객체 주소는 원본과 동일                  | 모든 객체가 독립된 주소를 가짐                |
| 변경 영향         | 내부 객체 변경 시 원본에도 영향               | 내부 객체 변경 시 원본에 영향 없음            |
| 사용 예시         | `copy.copy(obj)`                             | `copy.deepcopy(obj)`                         |
| 성능              | 빠름 (메모리 적게 사용)                      | 느림 (메모리 더 사용)                        |

## 예제
```python
marks1 = [['~'] * 5 for n in range(5)]
print(marks1)

'''
[['~', '~', '~', '~', '~'], ['~', '~', '~', '~', '~'], ['~', '~', '~', '~', '~'], ['~', '~', '~', '~', '~'], ['~', '~', '~', '~', '~']]
'''

marks2 = ['~' * 5 for _ in range(5)]
print(marks2)
'''
['~~~~~', '~~~~~', '~~~~~', '~~~~~', '~~~~~']
'''

marks3 = [['~'] * 3] * 4 # 한 개의 주소가 복사 된다 (주의가 필요하다)
print(marks3)
'''[['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~']]'''

marks4 = [['~'] * 3 for _ in range(4)]
print(marks4)
'''[['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~']]'''

marks3[0][1] = 'X'
marks4[0][1] = 'X'
print(marks3)
print(marks4)
'''
[['~', 'X', '~'], ['~', 'X', '~'], ['~', 'X', '~'], ['~', 'X', '~']]
[['~', 'X', '~'], ['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~']]
'''

print([id(i) for i in marks3])
print([id(i) for i in marks4])
'''
[4373518720, 4373518720, 4373518720, 4373518720]
[4372124288, 4372431680, 4390275200, 4390273536]
'''
```

## 🔍 예제 분석
### ✅ marks1 = [['~'] * 5 for n in range(5)]
- 리스트 컴프리헨션으로 각 행이 독립된 리스트 생성
- Deep Copy처럼 동작 (내부 리스트 주소 다름)

### ✅ marks2 = ['~' * 5 for _ in range(5)]
- 문자열을 5번 반복한 결과를 리스트에 담음
- 문자열은 불변 객체이므로 복사 여부와 무관

### ✅ marks3 = [['~'] * 3] * 4
- ['~'] * 3 하나만 만들고, 그걸 4번 참조함
- Shallow Copy → 내부 리스트 주소가 모두 같음

### ✅ marks4 = [['~'] * 3 for _ in range(4)]
- 리스트 컴프리헨션으로 각 행을 새로 생성
- 내부 리스트 주소가 모두 다름 → Deep Copy처럼 동작

### 🔧 결과 비교
```python
marks3[0][1] = 'X'
print(marks3)
# 모든 행의 두 번째 요소가 'X'로 바뀜 → 내부 리스트가 공유됨

marks4[0][1] = 'X'
print(marks4)
# 첫 번째 행만 바뀜 → 내부 리스트가 독립됨
```


### 🧪 메모리 주소 확인
```python
print([id(i) for i in marks3])
# [4373518720, 4373518720, 4373518720, 4373518720] → 모두 동일

print([id(i) for i in marks4])
# [4372124288, 4372431680, 4390275200, 4390273536] → 모두 다름

```

## 📘 요약 테이블
| 변수     | 생성 방식                         | 복사 유형       | 내부 주소 동일 여부 | 수정 시 영향       |
|----------|----------------------------------|------------------|----------------------|---------------------|
| marks1   | 리스트 컴프리헨션                 | Deep Copy처럼     | ❌ (다름)             | 독립적으로 수정 가능 |
| marks2   | 문자열 반복                       | 불변 객체         | N/A                  | 수정 불가            |
| marks3   | 리스트 * 반복                     | Shallow Copy      | ✅ (같음)             | 전체가 같이 바뀜     |
| marks4   | 리스트 컴프리헨션                 | Deep Copy처럼     | ❌ (다름)             | 부분 수정 가능        |


## 💡 실전 팁
- [[...]] * n은 절대 주의 → 내부 리스트가 공유됨
- copy.deepcopy()를 쓰면 진짜 Deep Copy 가능
- id()로 객체 주소를 확인하면 복사 여부를 쉽게 판단 가능

---
