# 색인 연산자란?

Python에서 obj[key] 또는 obj[index]처럼 []를 사용하는 연산을 **색인 연산(indexing)**이라고 함. 
이 연산은 내부적으로 다음과 같이 동작해:
- obj[key] → obj.__getitem__(key)
- obj[key] = value → obj.__setitem__(key, value)
즉, 우리가 []를 쓰는 순간 Python은 해당 객체에 대해 이 두 메서드를 자동 호출해.

## 🧪 예제 분석: Seq 클래스
```python
class Seq(cols.UserList):
    def __getitem__(self, i):
        print("Seq getitem")
        ...
    def __setitem__(self, i, val):
        print("Seq setitem")
        ...
```

## ✅ 특징
- UserList를 상속받아 리스트처럼 동작
- __getitem__()과 __setitem__()을 오버라이드해서 커스터마이징
- 인덱스가 범위를 벗어나면 마지막 값을 반환하거나 새 값을 추가함
## ✅ 실무 활용
- 안전한 리스트 접근: 인덱스 초과 시 에러 대신 마지막 값 반환
- 자동 확장 리스트: 인덱스가 리스트 길이와 같으면 자동으로 append()

## 🧪 예제 분석: UserDict 클래스
```python
class UserDict(collections.UserDict):
    def __getitem__(self, key):
        print("UserDict getitem")
        return self.data.get(key)
    def __setitem__(self, key, value):
        print("UserDict setitem")
        self.data[key] = value
```

## ✅ 특징
- UserDict를 상속받아 딕셔너리처럼 동작
- __getitem__()은 .get()을 사용해 키가 없을 때 None 반환
- __setitem__()은 일반적인 딕셔너리처럼 동작
## ✅ 실무 활용
- 안전한 딕셔너리 접근: 키가 없을 때 KeyError 대신 None 반환
- 로깅/디버깅: 접근 시마다 로그 출력 가능
- 기본값 처리: .get()을 활용해 기본값 로직 삽입 가능

## 🧠 실무에서 색인 연산자 커스터마이징이 중요한 이유

| 상황 또는 목적           | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 안전한 데이터 접근        | 인덱스 초과나 키 미존재 시 에러 대신 기본값 또는 마지막 값 반환 가능       |
| 자동 확장 또는 삽입       | 리스트나 딕셔너리에 새로운 항목을 자동으로 추가하거나 확장 가능             |
| 로깅 및 디버깅 지원       | `__getitem__` / `__setitem__`에서 접근 로그 출력으로 추적 가능              |
| 직관적인 인터페이스 설계  | 사용자 정의 클래스에서 `[]`를 통해 자연스럽고 익숙한 방식으로 데이터 접근 가능 |
| 비즈니스 로직 내장        | 색인 접근 시 조건 검사, 권한 확인, 데이터 변환 등 커스텀 로직 삽입 가능       |



## 🔧 참고: 색인 관련 특수 메서드

| 메서드                  | 호출 방식            | 설명                                                                 |
|--------------------------|----------------------|----------------------------------------------------------------------|
| `__getitem__(key)`       | `obj[key]`           | 색인 접근 시 호출됨. 읽기 동작을 정의                                |
| `__setitem__(key, val)` | `obj[key] = val`     | 색인 할당 시 호출됨. 쓰기 동작을 정의                                |
| `__delitem__(key)`       | `del obj[key]`       | 색인 삭제 시 호출됨. 항목 제거 동작을 정의                           |
| `__contains__(key)`      | `key in obj`         | 포함 여부 검사 시 호출됨. `in` 연산자 동작을 정의                     |

---

## 🔍 1. 슬라이스 대응: obj[start:stop]
### ✅ 핵심 개념
- obj[1:3]처럼 슬라이스가 들어오면 __getitem__의 key는 slice 객체가 됨
- slice.start, slice.stop, slice.step 속성을 사용해 범위 처리 가능
### 🧪 예제
```python
class MyList:
    def __init__(self, data):
        self.data = data

    def __getitem__(self, key):
        if isinstance(key, slice):
            print(f"슬라이스 접근: {key.start} ~ {key.stop}")
            return self.data[key]
        print(f"단일 인덱스 접근: {key}")
        return self.data[key]
```
ml = MyList([10, 20, 30, 40, 50])
print(ml[1:4])  # 슬라이스 접근: 1 ~ 4 → [20, 30, 40]
print(ml[2])    # 단일 인덱스 접근: 2 → 30



## 🔍 2. 다차원 인덱싱: obj[x, y]
✅ 핵심 개념
- obj[x, y]는 __getitem__에 key로 튜플 (x, y)가 전달됨
- 이를 분해해서 원하는 방식으로 처리 가능
### 🧪 예제
```python
class Grid:
    def __init__(self, rows, cols):
        self.data = [[f"{r},{c}" for c in range(cols)] for r in range(rows)]

    def __getitem__(self, key):
        if isinstance(key, tuple) and len(key) == 2:
            row, col = key
            print(f"다차원 접근: ({row}, {col})")
            return self.data[row][col]
        raise IndexError("2차원 인덱스 필요")

grid = Grid(3, 3)
print(grid[1, 2])  # 다차원 접근: (1, 2) → '1,2'
```



### 🧠 실무에서 왜 중요한가?

| 상황 또는 목적           | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 안전한 데이터 접근        | 인덱스 초과나 키 미존재 시 에러 대신 기본값 또는 마지막 값 반환 가능       |
| 자동 확장 또는 삽입       | 리스트나 딕셔너리에 새로운 항목을 자동으로 추가하거나 확장 가능             |
| 직관적인 인터페이스 설계  | 사용자 정의 클래스에서 `[]`를 통해 익숙하고 명확한 데이터 접근 방식 제공     |
| 조건부 로직 삽입 가능      | 색인 접근 시 권한 검사, 유효성 확인, 데이터 변환 등 커스텀 로직 구현 가능     |
| 슬라이스 및 다차원 처리    | `obj[1:3]`, `obj[x, y]` 등 고급 인덱싱을 통해 복잡한 구조를 간결하게 처리 가능 |



---
