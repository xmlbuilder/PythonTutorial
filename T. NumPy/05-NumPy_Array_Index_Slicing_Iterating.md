# Basic Indexing, Slicing, Iterating

## 🟦 1. 기본 인덱싱 (Indexing)
```python
a = np.arange(10) ** 3
print(a)        # [  0   1   8  27  64 125 216 343 512 729]
print(a[2])     # 8
print(a[-1])    # 729

```
- a[i]: i번째 요소 접근
- a[-1]: 마지막 요소

## 🟨 2. 슬라이싱 (Slicing)
```python
print(a[2:5])       # [ 8 27 64]
print(a[:6:2])      # [ 0  8 64]
a[:6:2] = -1000
print(a)            # [-1000     1 -1000    27 -1000   125   216   343   512   729]
```

- a[start:stop:step]: 부분 배열 추출
- 슬라이싱은 **뷰(view)**를 반환 → 원본 수정 가능

## 🟩 3. 역순 슬라이싱
```python
b = a[::-1]
print(b)
# [729 512 343 216 125 -1000 27 -1000 1 -1000]
```

- [::-1]: 배열을 뒤집음
- 자주 쓰이는 패턴: 리버스 배열

## 🟧 4. 반복(iterating)과 연산
```python
for i in a:
    print(i ** (1/3.))
```
###  출력 결과
```
nan
1.0
nan
3.0
nan
4.999999999999999
5.999999999999999
6.999999999999999
7.999999999999999
8.999999999999998
```

- 음수의 세제곱근은 실수로 표현 불가 → nan 발생
- 실수 연산 시 np.cbrt() 사용 추천
```python
np.seterr(invalid='ignore')  # nan 경고 무시
np.cbrt(a)  # 안전한 세제곱근 계산
```


### 🔹 샘플 코드
```python
import numpy as np

a = np.arange(10) ** 3
a[:6:2] = -1000  # 일부 값을 음수로 변경

print("배열 a:")
print(a)

print("\nnp.cbrt(a):")
print(np.cbrt(a))
```

### 🧪 출력 결과
```
배열 a:
[-1000     1 -1000    27 -1000   125   216   343   512   729]

np.cbrt(a):
[-10.   1. -10.   3. -10.   5.   6.   7.   8.   9.]
```


### 🧠 결과 해석
- np.cbrt()는 음수도 정상적으로 처리해서 -1000의 세제곱근을 -10.0으로 반환함
- ** (1/3.) 방식은 음수 입력 시 nan이 발생하지만, np.cbrt()는 그런 문제 없이 안전함
- 출력 결과는 실수(float)로 반환되며, 정밀도도 충분히 높음


## 🟨 5. 다차원 인덱싱과 슬라이싱
```python
def f(x, y): return 10*x + y
b = np.fromfunction(f, (5, 4), dtype=int)
print(b)
# [[ 0  1  2  3]
#  [10 11 12 13]
#  [20 21 22 23]
#  [30 31 32 33]
#  [40 41 42 43]]

print(b[2, 3])       # 23
print(b[0:5, 1])     # [ 1 11 21 31 41]
print(b[:, 1])       # [ 1 11 21 31 41]
print(b[1:3, :])     # [[10 11 12 13], [20 21 22 23]]
print(b[-1])         # [40 41 42 43]
print(b[-1, :])      # [40 41 42 43]
```

- b[i, j]: i행 j열 요소
- b[:, j]: j열 전체
- b[i, :]: i행 전체
- b[i:j, :]: i~j행 전체

### 🧠 보강 포인트 (Indexing, Slicing, Iterating)
| 표현 또는 함수         | 예시 또는 결과            | 설명                                                             |
|------------------------|----------------------------|------------------------------------------------------------------|
| `np.cbrt()`            | `np.cbrt([-1000]) → -10.0` | 세제곱근 계산 시 `nan` 방지 → 음수도 안전하게 처리됨               |
| `np.fromfunction()`    | `np.fromfunction(f, (5,4))`| 인덱스를 기반으로 배열 생성 → 함수형 초기화에 유용                  |
| `[::-1]`               | `a[::-1]`                  | 배열을 역순으로 뒤집음 → 리버스 슬라이싱                           |
| `-1`, `-2`             | `a[-1]`, `a[-2]`            | 음수 인덱스 → 끝에서부터 요소 접근 (`-1`은 마지막, `-2`는 끝에서 두 번째) |
| `a[:6:2] = value`      | `a[:6:2] = -1000`          | 슬라이싱은 뷰(view) → 원본 배열 직접 수정 가능                     |
| `a[::]`                | 전체 복사                  | 슬라이싱을 통한 전체 배열 복사 → `a.copy()`와 유사하지만 뷰 반환     |
| `a.shape`              | `(3, 4)`                   | 배열의 구조 확인 → 인덱싱과 슬라이싱 시 필수 정보                   |
| `a.ndim`               | `2`                        | 배열의 차원 수 확인 → 반복 구조 설계에 활용                         |
| `a.size`               | `12`                       | 전체 요소 개수 → 반복 또는 조건 처리 시 유용                        |
| `np.nditer()`          | `for x in np.nditer(a)`    | 다차원 배열 반복 시 사용 → 효율적인 순회 가능                       |


### 🔍 실무 팁 요약
- 슬라이싱은 뷰를 반환하므로 원본 배열이 바뀔 수 있음 → copy()로 복사 필요 시 명시적으로 사용
- 음수 인덱스는 배열 끝에서부터 접근할 때 유용 → 특히 마지막 행/열 추출 시 자주 사용됨
- **np.nditer()**는 다차원 배열을 1D처럼 순회할 수 있게 해줘 → 반복문 최적화에 유리
- **np.cbrt()**는 x ** (1/3)보다 안전 → 음수 입력 시 nan 방지


----
## 🔹 np.nditer() — 다차원 배열 반복자
### ✅ 설명
- NumPy의 다차원 배열을 효율적으로 반복할 수 있게 해주는 도구
- 일반적인 for i in arr:는 1D 배열에 적합하지만, nditer()는 모든 차원에 대해 순회 가능
### 🔧 예시
```python
a = np.array([[1, 2], [3, 4]])
for x in np.nditer(a):
    print(x)
```

### 출력
```
1
2
3
4
```

### 🧠 실무 팁
- nditer()는 읽기 전용이 기본이지만, op_flags=['readwrite']로 수정도 가능
- order='F'로 Fortran 방식(열 우선) 순회도 가능



## 🔹 조건 필터링 — Boolean Indexing
### ✅ 설명
- 조건을 만족하는 요소만 추출하거나 수정할 수 있음
### 🔧 예시
```python
a = np.array([10, 20, 30, 40])
mask = a > 25
print(a[mask])  # [30 40]
```


##🔹 np.where() — 조건 기반 선택
### ✅ 설명
- 조건을 만족하는 위치 또는 값을 선택
- np.where(condition, x, y) → 조건이 참이면 x, 거짓이면 y
### 🔧 예시
```python
a = np.array([10, 20, 30, 40])
print(np.where(a > 25))        # (array([2, 3]),)
print(np.where(a > 25, 1, 0))  # [0 0 1 1]
```


## 🔹 np.take() — 인덱스 기반 선택
### ✅ 설명
- 지정한 인덱스 위치의 요소를 빠르게 추출
- 다차원 배열에서도 flatten된 형태로 작동
#### 🔧 예시
```python
a = np.array([10, 20, 30, 40])
indices = [0, 2]
print(np.take(a, indices))  # [10 30]
```


### 🔹 np.choose() — 조건 배열에 따라 여러 배열 중 선택
### ✅ 설명
- 인덱스 배열을 기반으로 여러 배열 중에서 선택
- np.choose(choice_array, [option1, option2, ...])
### 🔧 예시
```python
choices = np.array([0, 1, 0, 1])
option1 = [100, 200, 300, 400]
option2 = [1, 2, 3, 4]
print(np.choose(choices, [option1, option2]))
# [100   2 300   4]
```

### 🧪 예시 코드 (3개의 옵션 배열)
```python
import numpy as np

choices = np.array([0, 1, 2, 1, 0])
option0 = [10, 20, 30, 40, 50]
option1 = [1, 2, 3, 4, 5]
option2 = [100, 200, 300, 400, 500]

result = np.choose(choices, [option0, option1, option2])
print(result)
```

### ✅ 출력 결과
```
[10  2 300  4 50]
```
### 🧠 보강 포인트
| 인덱스 값 | 선택된 배열 | 선택된 값 |
|-----------|--------------|------------|
| 0         | option0      | 10         |
| 1         | option1      | 2          |
| 2         | option2      | 300        |
| 1         | option1      | 4          |
| 0         | option0      | 50         |



## 🧠 요약 표
| 함수            | 기능 설명                                 | 예시 결과                     |
|-----------------|--------------------------------------------|-------------------------------|
| `np.nditer()`   | 다차원 배열 순회                           | 1, 2, 3, 4                    |
| 조건 필터링     | 조건에 맞는 요소만 추출                    | `[30 40]`                     |
| `np.where()`    | 조건에 따라 위치 또는 값 선택              | `[0 0 1 1]`                   |
| `np.take()`     | 인덱스 기반 요소 선택                      | `[10 30]`                     |
| `np.choose()`   | 인덱스 배열에 따라 여러 배열 중 선택       | `[100 2 300 4]`               |


## 💬 한마디
인덱싱과 슬라이싱은 NumPy의 기본 중 기본이야.
특히 다차원 배열에서 :와 -1을 자유자재로 쓰면
데이터 접근, 전처리, 시각화가 훨씬 쉬워짐.

