# Broadcasting Rule
NumPy의 핵심 기능 중 하나인 Broadcasting Rule을 그 원리를 단계적으로 설명.

## 📘 Broadcasting Rule이란?
서로 다른 shape을 가진 배열끼리 연산할 때,
NumPy가 자동으로 shape을 맞춰주는 규칙이야.


## ✅ Broadcasting이 적용되는 조건
두 배열의 shape을 오른쪽부터 비교하면서 다음 조건을 만족해야 해:
- 같은 크기이거나
- 한쪽이 1이면 확장 가능

## 🔍 예제별 설명
### ① 실패 예시: x + y
x.shape → (4,)
y.shape → (5,)

```python
import numpy as np

x = np.arange(4)
print(x)
'[0 1 2 3]'
xx = x.reshape(4, 1)
print(xx)
'''
[[0]
 [1]
 [2]
 [3]]
 '''
y = np.ones(5)
print(y)
'''[1. 1. 1. 1. 1.]'''

#print(x + y)
'''
Traceback (most recent call last):
  File "/Users/jeongjunghwan/PycharmProjects/Tutorial2/numpy_test.py", line 24, in <module>
    print(x + y)
          ~~^~~
ValueError: operands could not be broadcast together with shapes (4,) (5,) 
'''
```
- 오른쪽부터 비교: 4 vs 5 → ❌ 불일치
- 둘 다 1이 아니므로 broadcasting 불가 → ValueError



## ② 성공 예시: xx + y
xx.shape → (4, 1)
y.shape  → (5,)
→ y → (1, 5)로 자동 확장됨
→ 결과 shape: (4, 5)


### ② 성공 예시: xx + y → Broadcasting 결과

| xx (4×1)  | y (1×5)        | 결과 (4×5) 행렬             |
|-----------|----------------|------------------------------|
| [[0]      | [1 1 1 1 1]    | [1. 1. 1. 1. 1.]             |
|  [1]      |                | [2. 2. 2. 2. 2.]             |
|  [2]      |                | [3. 3. 3. 3. 3.]             |
|  [3]]     |                | [4. 4. 4. 4. 4.]             |

```python
print(xx + y)
'''
[[1. 1. 1. 1. 1.]
 [2. 2. 2. 2. 2.]
 [3. 3. 3. 3. 3.]
 [4. 4. 4. 4. 4.]]
 '''
print((xx+y).shape)
'''(4, 5)'''

```
### 🔍 Broadcasting 처리 흐름
- xx.shape = (4, 1) → 세로 벡터
- y.shape = (5,) → 가로 벡터
- NumPy는 y를 (1, 5)로 확장하고, xx를 (4, 1)로 유지
- 두 배열을 더하면 → (4, 5) 결과 생성


### ③ 성공 예시: x + z → Broadcasting 결과
| x (1×4)     | z (3×4)                     | 결과 (3×4) 행렬             |
|-------------|-----------------------------|------------------------------|
| [0 1 2 3]   | [[1. 1. 1. 1.]              | [1. 2. 3. 4.]                |
|             |  [1. 1. 1. 1.]              | [1. 2. 3. 4.]                |
|             |  [1. 1. 1. 1.]]             | [1. 2. 3. 4.]                |

```python
print(x)
'''[0 1 2 3]'''
print(z)
'''
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
'''

print(x+z)
'''
[[1. 2. 3. 4.]
 [1. 2. 3. 4.]
 [1. 2. 3. 4.]]
 '''

 
````


④ 성공 예시: c + b → Broadcasting 결과

| c (4×1)         | b (1×3)        | 결과 (4×3) 행렬             |
|------------------|----------------|------------------------------|
| [ 0.]            | [1. 2. 3.]     | [ 1.  2.  3.]                |
| [10.]            |                | [11. 12. 13.]                |
| [20.]            |                | [21. 22. 23.]                |
| [30.]            |                | [31. 32. 33.]                |


📘 Broadcasting 시각화 요약
| A.shape   | B.shape   | Result.shape | 설명                         |
|-----------|-----------|--------------|------------------------------|
| (4,)      | (5,)      | ❌ 오류       | 4 ≠ 5 → 둘 다 1이 아님       |
| (4, 1)    | (5,)      | (4, 5)       | 1 → 5 확장 가능              |
| (4,)      | (3, 4)    | (3, 4)       | x → (1, 4)로 확장됨          |
| (4, 1)    | (3,)      | (4, 3)       | b → (1, 3)로 확장됨          |



💬 한마디
Broadcasting은 NumPy의 벡터화 연산을 가능하게 하는 핵심 기술이야.
덕분에 for문 없이도 다양한 shape의 배열끼리
빠르고 직관적으로 연산할 수 있지.
단, shape이 맞지 않으면 오류가 나니까
항상 shape을 먼저 확인하는 습관이 중요해!


