# 📦 Basic — Indexing with Boolean Arrays


## ✅ 1. 조건 기반 Boolean 인덱싱
```python
import numpy as np
a = np.arange(12).reshape(3, 4)

b = a > 4
# → 조건을 만족하는 위치만 True

print(b)
→ [[False False False False]
   [False  True  True  True]
   [ True  True  True  True]]
```

```python
c = a[b]
# → True 위치의 값만 추출
→ [ 5  6  7  8  9 10 11]
```

```python
a[b] = 0
# → 조건을 만족하는 위치에 0 대입

print(a)
→ [[0 1 2 3]
   [4 0 0 0]
   [0 0 0 0]]
```

## ✅ 2. 행/열 Boolean 인덱싱
```python
a = np.arange(12).reshape(3, 4)

b1 = np.array([False, True, True])      # 행 선택
b2 = np.array([True, False, True, False]) # 열 선택

b = a[b1, :]
# → 행 1, 2 선택
→ [[ 4  5  6  7]
   [ 8  9 10 11]]

c = a[:, b2]
# → 열 0, 2 선택
→ [[ 0  2]
   [ 4  6]
   [ 8 10]]

d = a[b1, b2]
# → (1,0), (2,2) 위치 추출
→ [ 4 10]
```

## ✅ 3. 조합 인덱싱 (행 먼저 → 열 선택)
```python
b = a[b1, :]      # 행 1, 2 선택
c = b[:, b2]      # 선택된 행에서 열 0, 2 선택
→ [[ 4  6]
   [ 8 10]]
```

## ✅ 4. 조합 인덱싱 (열 먼저 → 행 선택)
```python
c = a[:, b2]      # 열 0, 2 선택
b = c[b1, :]      # 선택된 열에서 행 1, 2 선택
→ [[ 4  6]
   [ 8 10]]

````

## 🧠 핵심 요약 — Boolean Indexing
| 표현                         | 동작 방식                                      | 결과 형태 및 설명                          |
|------------------------------|------------------------------------------------|--------------------------------------------|
| a[b]                         | 조건을 만족하는 요소만 1D로 추출               | shape: (n,), True 위치의 값만 추출         |
| a[b1, :]                     | 행 마스크 b1로 행 선택                         | shape: (행 수, 열 수), 선택된 행 전체      |
| a[:, b2]                     | 열 마스크 b2로 열 선택                         | shape: (행 수, 열 수), 선택된 열 전체      |
| a[b1, b2]                    | (b1[k], b2[k]) 위치의 값 추출                  | shape: (n,), 좌표 쌍 기준으로 1D 추출      |
| a[b1][:, b2] 또는 a[:, b2][b1] | 행 먼저 선택 후 열 선택 (또는 반대 순서)       | shape: (행 수, 열 수), 순차적 필터링 결과  |


💬 한마디
Boolean 인덱싱은 단순한 필터링을 넘어서  
조건 기반 추출, 마스크 처리, 행/열 조합 선택에 핵심.  
특히 a[b1, b2]는 좌표 쌍으로 작동하고  
a[b1][:, b2]는 순차적 필터링이라는 걸 기억하면 좋아.  

## 샘플
```python

import numpy as np
a = np.arange(12).reshape(3, 4)
b = a > 4
print(b)
'''
[[False False False False]
 [False  True  True  True]
 [ True  True  True  True]]
'''
c = a[b]
print(c)
'''
[ 5  6  7  8  9 10 11]
'''
a[b] = 0
print(a)
'''
[[0 1 2 3]
 [4 0 0 0]
 [0 0 0 0]]
'''
import numpy as np
a = np.arange(12).reshape(3,4)
b1 = np.array([False, True, True])
b2 = np.array([True, False, True, False])
b = a[b1, :]
print(b)
'''
[[ 4  5  6  7]
 [ 8  9 10 11]]
 '''
c = a[:, b2]
print(c)
'''
[[ 0  2]
 [ 4  6]
 [ 8 10]]
 '''
d = a[b1,b2]
print(d)
'''[ 4 10]'''

b = a[b1, :]
c = b[:, b2]
print(c)
'''
[[ 4  6]
 [ 8 10]]
 '''
c = a[:, b2]
b = c[b1, :]
print(b)
'''
[[ 4  6]
 [ 8 10]]
 '''
print([b1,b2])
'''[array([False,  True,  True]), array([ True, False,  True, False])]'''

```
---

## 🧠 고급 Boolean 인덱싱 함수 요약 — np.where, np.nonzero, np.take, np.put
| 함수         | 기능 설명                                      | 주요 특징 및 용도                        |
|--------------|------------------------------------------------|------------------------------------------|
| np.where()   | 조건에 따라 인덱스 또는 값을 선택              | 조건 필터링, if-else처럼 사용 가능       |
| np.nonzero() | True인 위치의 인덱스를 반환                    | 다차원 배열에서 조건 위치 추출           |
| np.take()    | 지정된 인덱스 위치의 값만 추출                 | 축 지정 가능, 빠른 인덱싱                |
| np.put()     | 지정된 위치에 값 대입                          | 직접 위치 지정하여 값 변경               |



## ✅ 1. np.where() — 조건 기반 선택
```python
a = np.array([10, 20, 30, 40])
b = np.where(a > 25)
# → 조건을 만족하는 인덱스 반환
→ (array([2, 3]),)

c = np.where(a > 25, 1, 0)
# → 조건에 따라 값 선택 (if-else)
→ [0 0 1 1]
```


## ✅ 2. np.nonzero() — True 위치 인덱스 반환
```python
a = np.array([[0, 1, 0], [2, 0, 3]])
b = np.nonzero(a)
# → 조건 없이 0이 아닌 값의 위치 반환
→ (array([0, 1, 1]), array([1, 0, 2]))

# 위치를 이용해 값 추출
a[b] → [1 2 3]
```


## ✅ 3. np.take() — 인덱스 위치의 값 추출
```python
a = np.array([10, 20, 30, 40])
b = np.take(a, [0, 2])
→ [10 30]

# 다차원 배열에서 축 지정
m = np.arange(6).reshape(2, 3)
np.take(m, [0, 2], axis=1)
→ [[0 2]
   [3 5]]
```



## ✅ 4. np.put() — 위치 지정하여 값 대입
```python
a = np.array([10, 20, 30, 40])
np.put(a, [0, 2], [100, 300])
→ a = [100 20 300 40]

# 다차원 배열에도 사용 가능

m = np.zeros((2, 3))
np.put(m, [0, 4], [1, 9])
→ m = [[1. 0. 0.]
       [0. 9. 0.]]

```
## 💡 실무 팁 — 고급 Boolean 인덱싱 함수 활용
| 함수         | 실무 활용 예시                                | 특징 요약                          |
|--------------|------------------------------------------------|------------------------------------|
| np.where()   | 조건에 따라 값 선택 또는 위치 추출              | if-else 로직, 마스크 처리에 유용   |
| np.nonzero() | 조건을 만족하는 위치 인덱스 추출                | 희소 행렬, 위치 기반 필터링        |
| np.take()    | 특정 인덱스 위치의 값만 빠르게 추출             | 축 지정 가능, 고속 피처 선택       |
| np.put()     | 특정 위치에 값 삽입 또는 조건 기반 값 수정      | 직접 위치 지정, 마스크 기반 수정   |


💬 한마디
이 함수들은 단순한 인덱싱을 넘어서
조건 기반 추출, 위치 기반 수정, 고속 데이터 처리에 핵심이야.
특히 np.where와 np.take는
모델 입력 구성, 마스크 처리, 피처 선택에 자주 쓰이지.

---

##🔍 전체 코드
```python
m = np.zeros((2, 3))
np.put(m, [0, 4], [1, 9])
```


## ✅ Step-by-Step 절차
### ① 배열 생성
```python
m = np.zeros((2, 3))
```

- m은 2행 3열의 2D 배열
- 초기값은 모두 0
```python
m =
[[0. 0. 0.]
 [0. 0. 0.]]
```


### ② 인덱스 확인
```python
np.put(m, [0, 4], [1, 9])
```

- np.put()은 1D 인덱스 기준으로 값을 삽입
- m은 내부적으로 1D로 펼쳐짐: [0, 1, 2, 3, 4, 5]
- 인덱스 [0, 4]에 각각 [1, 9]를 삽입  


| 1D 인덱스 | 2D 위치 (행, 열) | 삽입 값 | 설명                      |
|-----------|------------------|---------|---------------------------|
| 0         | (0, 0)           | 1       | 첫 번째 요소에 1 삽입     |
| 4         | (1, 1)           | 9       | 다섯 번째 요소에 9 삽입   |


### ③ 결과 배열
m =
[[1. 0. 0.]
 [0. 9. 0.]]


## 🧠 핵심 요약
| 함수       | 동작 방식                              | reshape 필요 여부 | 특징 요약                          |
|------------|-----------------------------------------|-------------------|------------------------------------|
| np.put()   | 배열을 1D로 간주하고 지정된 위치에 값 삽입 | ❌ reshape 없이 가능 | 다차원 배열도 1D 인덱스로 직접 수정 |


## 🔧 예시
```python
m = np.zeros((2, 3))
np.put(m, [0, 4], [1, 9])
```

- m은 2D 배열이지만 내부적으로 [0, 1, 2, 3, 4, 5]로 간주됨
- np.put()은 reshape 없이도 [0, 4] 위치에 [1, 9] 삽입
### 결과:
```
[[1. 0. 0.]
 [0. 9. 0.]]
```



---


## 🧠 고급 선택 함수 요약 — np.choose, np.select, np.clip, np.compress
| 함수         | 기능 설명                                      | 주요 특징 및 용도                        |
|--------------|------------------------------------------------|------------------------------------------|
| np.choose()  | 인덱스 배열을 기준으로 여러 배열 중 값 선택     | 다중 선택, 색상 매핑, 조건 분기 등       |
| np.select()  | 여러 조건에 따라 대응하는 값을 선택             | if-elif-else 구조처럼 작동               |
| np.clip()    | 값의 범위를 제한 (min ≤ x ≤ max)               | 이상치 제거, 정규화, 경계 설정           |
| np.compress()| 조건을 만족하는 요소만 추출                    | Boolean 마스크 기반 필터링               |



## ✅ 1. np.choose() — 인덱스 기반 다중 선택
```python
index = np.array([0, 2, 1, 3])
options = [
    [10, 10, 10, 10],
    [20, 20, 20, 20],
    [30, 30, 30, 30],
    [40, 40, 40, 40]
]

np.choose(index, options)
→ [10 30 20 40]
```

- index[k]에 따라 options[index[k]][k] 선택
- 색상 매핑, 다중 조건 분기 등에 유용

## ✅ 2. np.select() — 조건별 값 선택
```python
x = np.array([0, 1, 2, 3, 4])
condlist = [x < 2, x > 3]

choicelist = [100, 999]

np.select(condlist, choicelist, default=-1)
→ [100 100 -1 -1 999]
```

- 조건 리스트와 선택 리스트를 매칭
- if-elif-else 구조처럼 작동

### 🔍 동작 절차 — np.select(condlist, choicelist, default)
예시:
```python
x = np.array([0, 1, 2, 3, 4])
condlist = [x < 2, x > 3]
choicelist = [100, 999]
default = -1
```

| 위치 | x 값 | 조건 1: x < 2 | 조건 2: x > 3 | 선택된 값 |
|------|------|----------------|----------------|------------|
| 0    | 0    | ✅ True         | ❌ False        | 100        |
| 1    | 1    | ✅ True         | ❌ False        | 100        |
| 2    | 2    | ❌ False        | ❌ False        | -1         |
| 3    | 3    | ❌ False        | ❌ False        | -1         |
| 4    | 4    | ❌ False        | ✅ True         | 999        |

- 조건은 순서대로 평가됨 (if → elif → else)
- 첫 번째 조건이 True면 첫 번째 선택값 사용
- 두 조건 모두 False면 default 값 사용


## ✅ 3. np.clip() — 값 범위 제한
```python
a = np.array([1, 5, 10, 15])
np.clip(a, 3, 12)
### 결론
```
[3 5 10 12]
```

- 최소값보다 작으면 min으로, 최대값보다 크면 max로 잘라냄
- 이상치 제거, 정규화에 유용


### 🔍 동작 절차 — np.select(condlist, choicelist, default)
예시:
```python
x = np.array([0, 1, 2, 3, 4])
condlist = [x < 2, x > 3]
choicelist = [100, 999]
default = -1
```

| 위치 | x 값 | 조건 1 (x < 2) | 조건 2 (x > 3) | 선택된 조건 | 선택된 값 |
|------|------|----------------|----------------|--------------|------------|
| 0    | 0    | ✅ True         | ❌ False        | 조건 1        | 100        |
| 1    | 1    | ✅ True         | ❌ False        | 조건 1        | 100        |
| 2    | 2    | ❌ False        | ❌ False        | 없음          | -1         |
| 3    | 3    | ❌ False        | ❌ False        | 없음          | -1         |
| 4    | 4    | ❌ False        | ✅ True         | 조건 2        | 999        |


## 💡 요점 정리
- 조건은 순서대로 평가됨 → 첫 번째로 True인 조건이 적용됨
- 조건이 모두 False인 경우 default 값이 사용됨
- 결과는 x와 같은 shape의 배열로 반환됨


## ✅ 4. np.compress() — Boolean 마스크 필터링
```python
a = np.array([[1, 2], [3, 4], [5, 6]])
mask = np.array([True, False, True])

np.compress(mask, a, axis=0)
```
### 결론
```
[[1 2]
[5 6]]
```

- axis 기준으로 True인 행/열만 추출
- np.where()보다 간결하게 필터링 가능

## 💡 실무 팁 요약 — np.choose, np.select, np.clip, np.compress

| 함수           | 실무 활용 예시                                | 특징 요약                          |
|----------------|------------------------------------------------|------------------------------------|
| np.choose()    | 색상 매핑, 다중 옵션 선택, 인덱스 기반 분기     | 여러 배열 중 인덱스에 따라 선택     |
| np.select()    | 조건 분기 처리, if-elif-else 로직 구현          | 조건 리스트에 따라 값 선택          |
| np.clip()      | 값 범위 제한, 이상치 제거, 정규화               | min/max 경계 설정으로 값 제어       |
| np.compress()  | 마스크 기반 행/열 필터링, 조건 만족 요소 추출   | Boolean 배열로 원하는 축 필터링     |

---

# np.choose()는 row(행) 기준으로 선택이 먼저 적용.
이건 index 배열이 행 인덱스처럼 작동하고, 각 행에 대해 해당하는 options 배열에서 값을 선택하는 방식.

### ✅ 핵심 동작 방식
index = np.array([0, 2, 1])
options = [
    [10, 10, 10],
    [20, 20, 20],
    [30, 30, 30]
]

np.choose(index, options)
→ [10, 30, 20]


## 📌 np.choose 동작 절차 — index[k]에 따라 options[index[k]][k] 선택

### 예시:
```python
index = [0, 2, 1, 3]
options = [
    [10, 10, 10, 10],
    [20, 20, 20, 20],
    [30, 30, 30, 30],
    [40, 40, 40, 40]
]
```

| 위치 k | index[k] | 선택된 배열 (options[index[k]]) | 선택된 값 (options[index[k]][k]) |
|--------|----------|----------------------------------|----------------------------------|
| 0      | 0        | [10, 10, 10, 10]                 | 10                               |
| 1      | 2       

- 즉, index[k]는 행 번호, options[index[k]][k]가 선택됨
- 열 방향으로 병렬 선택이 이루어짐


## 🧠 핵심 요약 — np.choose(index, options)
| 위치 k | index[k] | 선택된 배열 (options[index[k]]) | 선택된 값 (options[index[k]][k]) |
|--------|----------|----------------------------------|----------------------------------|
| 0      | 0        | options[0]                       | options[0][0] → 값 ①             |
| 1      | 2        | options[2]                       | options[2][1] → 값 ②             |
| 2      | 1        | options[1]                       | options[1][2] → 값 ③             |
| 3      | 3        | options[3]                       | options[3][3] → 값 ④             |


---

