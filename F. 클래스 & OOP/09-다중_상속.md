# 🧠 Python 다중 상속이란?

- 하나의 클래스가 둘 이상의 부모 클래스로부터 속성과 메서드를 상속받는 구조
- Python은 C3 선형화 알고리즘을 사용해 **MRO(Method Resolution Order)**를 계산함
- MRO는 메서드 탐색 순서를 결정하며, 왼쪽에서 오른쪽, 깊이 우선으로 탐색됨

## 예제
```python
class Person(object):
    def __init__(self, name, age, nation):
        print("Person initialized")
        self.name = name
        self.age = age
        self.nation = nation
    def say(self, message):
        return message

class GrandFather(Person):
    pass

class GrandMother(Person):
    pass

class Father(GrandFather, GrandMother):
    pass


print(Father.__bases__)
'''(<class '__main__.GrandFather'>, <class '__main__.GrandMother'>)'''

print(Father.mro())
'''
[<class '__main__.Father'>, <class '__main__.GrandFather'>, <class '__main__.GrandMother'>, 
<class '__main__.Person'>, <class 'object'>]
'''

f = Father("Jhjeong", 56, "Korea")

print(f.__dict__)
'''{'name': 'Jhjeong', 'age': 56, 'nation': 'Korea'}'''

class GrandFather_(Person):
    pass

class GrandMother_(Person):
    pass

class Mother(GrandFather_, GrandMother_):
    pass

print(Mother.__bases__)
'''(<class '__main__.GrandFather_'>, <class '__main__.GrandMother_'>)'''

print(Mother.mro())
'''
[<class '__main__.Mother'>, <class '__main__.GrandFather_'>, <class '__main__.GrandMother_'>, 
<class '__main__.Person'>, <class 'object'>]
'''

class Son(Father, Mother):
    pass

print(Son.__bases__)
'''(<class '__main__.Father'>, <class '__main__.Mother'>)'''

print(Son.mro())
'''
[<class '__main__.Son'>, 
<class '__main__.Father'>, <class '__main__.GrandFather'>, <class '__main__.GrandMother'>, 
class '__main__.Mother'>, <class '__main__.GrandFather_'>, <class '__main__.GrandMother_'>, 
<class '__main__.Person'>, <class 'object'>]
'''

s = Son("test", 11, "Canada")

print(s.say("Canada"))
'''Canada'''


```

### 🔍 예제 핵심 흐름

```python
class Son(Father, Mother): pass
```

- Son은 Father와 Mother를 상속
- Father는 GrandFather, GrandMother를 상속
- Mother는 GrandFather_, GrandMother_를 상속
- 모든 클래스는 결국 Person을 상속
#### MRO 결과
```python
Son.mro()
# [Son, Father, GrandFather, GrandMother, Mother, GrandFather_, GrandMother_, Person, object]
```

- Person은 중복되지만 한 번만 포함됨
- 메서드 탐색 시 이 순서대로 진행됨

## 🧩 핵심 메서드
| 메서드       | 역할                                | 예시 사용                         |
|--------------|-------------------------------------|-----------------------------------|
| `__bases__`  | 직접 상속받은 부모 클래스 확인        | `Son.__bases__`                   |
| `mro()`      | 메서드 탐색 순서(Method Resolution Order) | `Son.mro()`                       |
| `__dict__`   | 인스턴스 또는 클래스의 속성 저장소     | `s.__dict__`, `Son.__dict__`      |


## 📘 다중 상속 요약 테이블
| 항목             | 설명                                         | 예시                          |
|------------------|----------------------------------------------|-------------------------------|
| 다중 상속         | 여러 부모 클래스로부터 속성/메서드 상속       | `class Son(Father, Mother)`   |
| `__bases__`       | 직접 부모 클래스 확인                         | `Son.__bases__`               |
| `mro()`           | 메서드 탐색 순서 확인                         | `Son.mro()`                   |
| `super()`         | MRO 기반으로 부모 메서드 호출                 | `super().__init__()`          |
| 중복 제거         | 동일 부모 클래스는 MRO에서 한 번만 포함됨      | `Person`은 한 번만 등장       |



## 💡 실전 팁
- super()는 MRO를 기반으로 동작하므로 다중 상속에서도 안전하게 부모 메서드 호출 가능
- 다중 상속 시 공통 부모 클래스는 한 번만 초기화됨 → Person initialized는 한 번만 출력
- 복잡한 상속 구조에서는 mro()를 꼭 확인하세요

---

# 🧠 1. super()의 내부 동작
## ✅ 핵심 개념
- super()는 **MRO(Method Resolution Order)**를 기반으로 부모 클래스의 메서드를 호출
- 다중 상속에서도 MRO 순서에 따라 안전하게 부모 메서드를 호출함

### 🔍 동작 방식
```python
class A:
    def greet(self):
        print("Hello from A")

class B(A):
    def greet(self):
        print("Hello from B")
        super().greet()

b = B()
b.greet()
# Hello from B
# Hello from A
```


- super()는 B의 다음 MRO인 A를 찾아서 greet() 호출
- 내부적으로 super(B, self)와 같은 형태로 동작
### 📘 요약
| 항목       | 설명                                  |
|------------|---------------------------------------|
| 기반       | MRO(Method Resolution Order)          |
| 안전성     | 다중 상속에서도 충돌 없이 부모 호출 가능 |
| 사용 방식  | `super().__init__()` 또는 `super().method()` |



## 🧠 2. __slots__과의 관계
### ✅ 핵심 개념
- __slots__은 인스턴스의 __dict__ 생성을 막아 메모리 최적화를 수행
- 상속 시 부모 클래스의 __slots__도 고려해야 함
### 🔍 동작 방식
```python
class A:
    __slots__ = ['x']

class B(A):
    __slots__ = ['y']

```

- B는 x, y만 속성으로 가질 수 있음
- super()로 초기화할 때 __slots__에 정의된 속성만 접근 가능

### ⚠️ 주의점
- __slots__을 사용하는 클래스끼리 상속할 경우, 모든 부모의 슬롯을 명시적으로 합쳐야 함
- __slots__을 쓰면 __dict__가 없어지므로 setattr() 등 일부 동적 속성 추가가 제한됨

## 🧠 3. ABC 추상 클래스와의 조합
### ✅ 핵심 개념
- ABC는 Abstract Base Class의 약자
- abc 모듈을 통해 추상 메서드 정의 가능
- 상속받는 클래스는 반드시 추상 메서드를 구현해야 함
### 🔍 동작 방식
```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"
```

- Animal은 추상 클래스
- Dog는 sound()를 구현하지 않으면 인스턴스 생성 불가
### 📘 요약
| 항목           | 설명                                      |
|----------------|-------------------------------------------|
| 모듈           | `abc`                                     |
| 핵심 데코레이터 | `@abstractmethod`                         |
| 목적           | 인터페이스 정의, 강제 구현                 |
| super() 조합    | 추상 클래스에서도 `super()` 호출 가능       |



## 🔗 세 가지 조합 예시
```python
class Base(ABC):
    __slots__ = ['x']

    def __init__(self, x):
        self.x = x

    @abstractmethod
    def show(self):
        pass

class Derived(Base):
    __slots__ = ['y']

    def __init__(self, x, y):
        super().__init__(x)
        self.y = y

    def show(self):
        print(f"x={self.x}, y={self.y}")

```

- super()로 부모 초기화
- __slots__으로 메모리 최적화
- ABC로 인터페이스 강제


---
